name: Generate Changelog & Release

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Version number (e.g., 1.0.5)'
        required: true
        type: string

jobs:
  create-release:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: read
      issues: read
    
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Get latest release
        id: latest_release
        run: |
          latest_tag=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          if [ -z "$latest_tag" ]; then
            echo "No previous tags found, using initial commit"
            echo "latest_tag=" >> $GITHUB_OUTPUT
          else
            echo "latest_tag=$latest_tag" >> $GITHUB_OUTPUT
          fi

      - name: Generate release notes
        id: release_notes
        uses: actions/github-script@v7
        with:
          script: |
            const latestTag = '${{ steps.latest_release.outputs.latest_tag }}';
            
            // Query for both PRs and Issues
            const query = `query ($owner: String!, $repo: String!, $base: String!) {
              repository(owner: $owner, name: $repo) {
                pullRequests: pullRequests(first: 100, states: MERGED, baseRefName: $base, orderBy: {field: UPDATED_AT, direction: DESC}) {
                  nodes {
                    title
                    number
                    mergedAt
                    labels(first: 5) {
                      nodes {
                        name
                      }
                    }
                    type: __typename
                  }
                }
                issues: issues(first: 100, states: CLOSED, orderBy: {field: UPDATED_AT, direction: DESC}) {
                  nodes {
                    title
                    number
                    closedAt
                    labels(first: 5) {
                      nodes {
                        name
                      }
                    }
                    type: __typename
                    isPullRequest: isPullRequest
                  }
                }
              }
            }`;

            const { repository } = await github.graphql(query, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              base: 'main'
            });

            // Combine and filter PRs and Issues
            let items = [
              ...repository.pullRequests.nodes.map(pr => ({
                ...pr,
                date: pr.mergedAt
              })),
              ...repository.issues.nodes
                .filter(issue => !issue.isPullRequest) // Exclude issues that are actually PRs
                .map(issue => ({
                  ...issue,
                  date: issue.closedAt
                }))
            ];

            // Filter items after the last release
            items = items.filter(item => {
              if (!latestTag) return true;
              return new Date(item.date) > new Date(context.payload.before);
            });

            // Group items by label and type
            const groupedItems = {
              features: { prs: [], issues: [] },
              enhancements: { prs: [], issues: [] },
              bugs: { prs: [], issues: [] },
              documentation: { prs: [], issues: [] },
              other: { prs: [], issues: [] } // For items without matching labels
            };

            items.forEach(item => {
              const labels = item.labels.nodes.map(label => label.name);
              const type = item.type === 'PullRequest' ? 'prs' : 'issues';
              
              // Determine the group based on labels
              let grouped = false;
              if (labels.includes('feature')) {
                groupedItems.features[type].push(item);
                grouped = true;
              }
              if (labels.includes('enhancement')) {
                groupedItems.enhancements[type].push(item);
                grouped = true;
              }
              if (labels.includes('bug')) {
                groupedItems.bugs[type].push(item);
                grouped = true;
              }
              if (labels.includes('documentation')) {
                groupedItems.documentation[type].push(item);
                grouped = true;
              }
              
              // If no matching labels, add to 'other'
              if (!grouped) {
                groupedItems.other[type].push(item);
              }
            });

            // Generate markdown
            let markdown = `## [${process.env.VERSION}] - ${new Date().toISOString().split('T')[0]}\n\n`;

            const categories = {
              features: 'Features',
              enhancements: 'Enhancements',
              bugs: 'Bug Fixes',
              documentation: 'Documentation',
              other: 'Other Changes'
            };

            for (const [key, title] of Object.entries(categories)) {
              const prs = groupedItems[key].prs;
              const issues = groupedItems[key].issues;
              
              if (prs.length > 0 || issues.length > 0) {
                markdown += `### ${title}\n\n`;
                
                if (prs.length > 0) {
                  markdown += `#### Pull Requests\n`;
                  prs.forEach(pr => {
                    markdown += `- ${pr.title} (#${pr.number})\n`;
                  });
                  markdown += '\n';
                }
                
                if (issues.length > 0) {
                  markdown += `#### Issues\n`;
                  issues.forEach(issue => {
                    markdown += `- ${issue.title} (#${issue.number})\n`;
                  });
                  markdown += '\n';
                }
              }
            }

            // Save release notes for both the release and changelog
            core.setOutput('notes', markdown);

      - name: Update CHANGELOG.md
        run: |
          if [ ! -f CHANGELOG.md ]; then
            echo "# Changelog\n\nAll notable changes to this project will be documented in this file.\n" > CHANGELOG.md
          fi
          echo "${{ steps.release_notes.outputs.notes }}" | cat - CHANGELOG.md > temp && mv temp CHANGELOG.md

      - name: Commit and push CHANGELOG.md
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add CHANGELOG.md
          git commit -m "docs: update changelog for version ${{ github.event.inputs.version }}"
          git push

      - name: Create Release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          VERSION: ${{ github.event.inputs.version }}
        with:
          tag_name: ${{ github.event.inputs.version }}
          release_name: Release ${{ github.event.inputs.version }}
          body: ${{ steps.release_notes.outputs.notes }}
          draft: false
          prerelease: false
