name: Generate Changelog & Release

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Version number (e.g., 1.0.5)'
        required: true
        type: string

jobs:
  create-release:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: read
      issues: read
    
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Get latest release
        id: latest_release
        run: |
          latest_tag=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          if [ -z "$latest_tag" ]; then
            echo "No previous tags found, using initial commit"
            echo "latest_tag=" >> $GITHUB_OUTPUT
          else
            echo "latest_tag=$latest_tag" >> $GITHUB_OUTPUT
          fi

      - name: Generate release notes
        id: release_notes
        uses: actions/github-script@v7
        with:
          script: |
            const latestTag = '${{ steps.latest_release.outputs.latest_tag }}';
            
            // Query for PRs
            const prQuery = `query ($owner: String!, $repo: String!, $base: String!) {
              repository(owner: $owner, name: $repo) {
                pullRequests(first: 100, states: MERGED, baseRefName: $base, orderBy: {field: UPDATED_AT, direction: DESC}) {
                  nodes {
                    title
                    number
                    mergedAt
                    labels(first: 5) {
                      nodes {
                        name
                      }
                    }
                  }
                }
              }
            }`;

            // Query for Issues (excluding PRs)
            const issueQuery = `query ($owner: String!, $repo: String!) {
              repository(owner: $owner, name: $repo) {
                issues(first: 100, states: CLOSED, orderBy: {field: UPDATED_AT, direction: DESC}) {
                  nodes {
                    title
                    number
                    closedAt
                    labels(first: 5) {
                      nodes {
                        name
                      }
                    }
                    pullRequest {
                      number
                    }
                  }
                }
              }
            }`;

            // Fetch PRs and Issues
            const prData = await github.graphql(prQuery, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              base: 'main'
            });

            const issueData = await github.graphql(issueQuery, {
              owner: context.repo.owner,
              repo: context.repo.repo
            });

            // Process PRs
            const prs = prData.repository.pullRequests.nodes.map(pr => ({
              ...pr,
              date: pr.mergedAt,
              type: 'pr'
            }));

            // Process Issues (excluding those that are PRs)
            const issues = issueData.repository.issues.nodes
              .filter(issue => !issue.pullRequest) // Exclude issues that are PRs
              .map(issue => ({
                title: issue.title,
                number: issue.number,
                date: issue.closedAt,
                labels: issue.labels,
                type: 'issue'
              }));

            // Combine and filter items after the last release
            let items = [...prs, ...issues].filter(item => {
              if (!latestTag) return true;
              return new Date(item.date) > new Date(context.payload.before);
            });

            // Group items by label and type
            const groupedItems = {
              features: { prs: [], issues: [] },
              enhancements: { prs: [], issues: [] },
              bugs: { prs: [], issues: [] },
              documentation: { prs: [], issues: [] },
              other: { prs: [], issues: [] }
            };

            items.forEach(item => {
              const labels = item.labels.nodes.map(label => label.name);
              const type = item.type === 'pr' ? 'prs' : 'issues';
              
              let grouped = false;
              if (labels.includes('feature')) {
                groupedItems.features[type].push(item);
                grouped = true;
              }
              if (labels.includes('enhancement')) {
                groupedItems.enhancements[type].push(item);
                grouped = true;
              }
              if (labels.includes('bug')) {
                groupedItems.bugs[type].push(item);
                grouped = true;
              }
              if (labels.includes('documentation')) {
                groupedItems.documentation[type].push(item);
                grouped = true;
              }
              
              if (!grouped) {
                groupedItems.other[type].push(item);
              }
            });

            // Generate markdown
            let markdown = `## [${process.env.VERSION}] - ${new Date().toISOString().split('T')[0]}\n\n`;

            const categories = {
              features: 'Features',
              enhancements: 'Enhancements',
              bugs: 'Bug Fixes',
              documentation: 'Documentation',
              other: 'Other Changes'
            };

            for (const [key, title] of Object.entries(categories)) {
              const prs = groupedItems[key].prs;
              const issues = groupedItems[key].issues;
              
              if (prs.length > 0 || issues.length > 0) {
                markdown += `### ${title}\n\n`;
                
                if (prs.length > 0) {
                  markdown += `#### Pull Requests\n`;
                  prs.forEach(pr => {
                    markdown += `- ${pr.title} (#${pr.number})\n`;
                  });
                  markdown += '\n';
                }
                
                if (issues.length > 0) {
                  markdown += `#### Issues\n`;
                  issues.forEach(issue => {
                    markdown += `- ${issue.title} (#${issue.number})\n`;
                  });
                  markdown += '\n';
                }
              }
            }

            // Save release notes for both the release and changelog
            core.setOutput('notes', markdown);

      - name: Update CHANGELOG.md
        run: |
          if [ ! -f CHANGELOG.md ]; then
            echo "# Changelog\n\nAll notable changes to this project will be documented in this file.\n" > CHANGELOG.md
          fi
          echo "${{ steps.release_notes.outputs.notes }}" | cat - CHANGELOG.md > temp && mv temp CHANGELOG.md

      - name: Commit and push CHANGELOG.md
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add CHANGELOG.md
          git commit -m "docs: update changelog for version ${{ github.event.inputs.version }}"
          git push

      - name: Create Release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          VERSION: ${{ github.event.inputs.version }}
        with:
          tag_name: ${{ github.event.inputs.version }}
          release_name: Release ${{ github.event.inputs.version }}
          body: ${{ steps.release_notes.outputs.notes }}
          draft: false
          prerelease: false
